%%
%% This is file `sample-acmsmall.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `acmsmall')
%%
%% IMPORTANT NOTICE:
%%
%% For the copyright see the source file.
%%
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-acmsmall.tex.
%%
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%%
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass
%% command.
%%
%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
%%
%%
\documentclass[nonacm]{acmart}
\usepackage{ottalt}
\usepackage{xspace}
\newcommand{\lang}{$\lambda^H$\xspace}
\inputott{rules}
%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
\citestyle{acmauthoryear}


%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{A Short and Mechanized Consistency Proof for a Dependent Type Theory}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Yiyun Liu}
\orcid{0009-0006-8717-2498}
\affiliation{%
  \institution{University of Pennsylvania}
  \city{Philadelphia}
  \country{USA}
}
\email{liuyiyun@seas.upenn.edu}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
% \renewcommand{\shortauthors}{Trovato et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
Proof by logical relation is a powerful technique that has been used
to derive metatheoretic properties of type systems, such as
consistency and parametricity. While there exists a
plethora of introductory materials about logical relation in the
context of simply typed lambda calculus and System F, a streamlined
presentation of proof by logical relation for a dependently language
is lacking in comparison. In this paper, I present a short
consistency proof for a dependently typed language that contains a
rich set of features, including an infinite and cumulative universe
hierarchy, natural numbers, and an intensional identity type. We have
fully mechanized the consistency proof using the Coq proof assistant
in under 1000 lines of code.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Logical Relation, Dependent Types, Logical Consistency, Coq}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
% Depending on its application, we care about certain metatheoretic
% properties about a type system. As a programming language, we may care
% about type soundness, which states that a well-typed never gets stuck
% during evaluation.
When a type system is used as a program logic where terms encode proofs, we
want our type system to be logically consistent, meaning
that the empty type is not inhabited.
This paper is specifically
about establishing logical consistency for a fully dependently typed
system with an infinite universe hierarchy and support for large
elimination. % The type system, presented in Section~\ref{sec:spec}, is
% most similar to Martin-Lof's predicate type theory with the minor
% difference that type conversion is based on untyped equality.

The proof of various dependently typed systems, including Martin-Lof's
type theory, has long been
established in the literature and therefore the consistency result of
this paper is not novel. Rather,
our goal is to present the proof in a form that is digestable by a
working type theorist and can be more readily mechanized in a proof
assistant. Compared to existing efforts at mechanizing logical
consistency or stronger properties such as existence of normal
form~\citep{nbeincoq},
decidable type checking~\citep{decagda}, our work is minimal since it requires very
little scaffolding and therefore results in an extremely succinct
proof of under 1000 lines of manually written Coq code for a dependent
type theory that is reasonably complete in its features.

The key technique that underlies our consistency proof is proof by
logical relation. In Section~\ref{sec:logrelstlc}, we review the
technique in the context of the simply typed lambda calculus. In
Section~\ref{sec:spec}, we present the dependent type theory of
interest. In Section~\ref{sec:logreldep}, we give the definition
of the logical relation for the dependent type theory. Rather than
presenting the logical relation as an inductive-recursive definition,
we use the more elementary concept of a partial function to capture
the interpretation of types. The alternative representation requires us
to show that the set of equations indeed defines a partial function;
that is, for each input, there should always be a unique
output.
From the interpretation function, we can define the semantic
typing judgment for the set of lambda terms.
In Section~\ref{sec:logrelproof}, we prove the fundamental lemma,
which states that syntactic typing implies semantic typing. Once the
fundamental lemma is established, logical consistency follows as a
trivial corollary.

The downside of a pen and paper proof is that the validity of the
definitions themselves can be dubious at times. When working with a
dependent type theory that has a universe hierarchy, an intuitive
understanding of naive set theory no longer suffices as the size of
sets matters. For example, the partial function representing the
interpretation of types does not immediately correspond to a valid
definition in a proof assistant. We cannot easily define it as a
function as proof assistants such as Coq and Agda only accept total
functions. We cannot naively encode the interpretation function as an
inductive relation either since we violate the strict positivity
constraint. A detailed discussion of how we work around such technical
issues can be distracting. However, what can be equally distracting is
following along a proof where even the validity of the statement is
not trusted. As a result, we clearly mark the ``suspicious''
definitions, and defer the discussion of these definitions
until Section~\ref{sec:logrelmech}, where we give an overview of our
short Coq mechanization proof and the various proof engineering
techniques we adopt to make the mechanization for tractable.

Finally, in Section~\ref{sec:relatedwork}, we give a short survey of
existing literature related to logical consistency about dependent
type theory.

\section{Review of Proof by Logical Relation}
\label{sec:logrelstlc}


\section{Specification of a Dependent Type Theory}
\label{sec:spec}
In this section, we present the dynamics and statics of the
dependent type theory whose logical consistency will be proven in
Section~\ref{sec:logrelproof}. For concision, we refer to this system
as \lang.

The syntax of \lang can be found in Figure~\ref{fig:syntax}. As a
dependent type theory, terms and types are collapsed into the same
syntactic category. Dependent functions take the form $[[Pi A B]]$ and
we use the notation $[[A -> B]]$ when the output type $[[B]]$ is not
dependent on the input variable. $[[Set i]]$ represents the universe
type where $[[i]]$ ranges over the set of natural numbers. Finally,
\lang also includes an intensional identity type $[[a ~ b : A]]$ whose
proofs can be eliminated by the J-eliminator $[[J t a b p]]$, where
$[[p]]$ is an equality proof between $[[a]]$ and $[[b]]$, and $[[t]]$
is the term whose type is to be casted.

\lang is expressive enough to support large
elimination, the ability to compute a type using a term as input. For
example, the function $[[\ Bool if 0 Bool Bool -> Bool]]$ returns
either $[[Bool]]$ or $[[Bool -> Bool]]$ depending on whether the input
is $[[true]]$ or $[[false]]$.

Figure~\ref{fig:par} shows the definition of the parallel reduction
relation, which takes the form $[[a => b]]$. We use $[[a =>+ b]]$ to
represent its transitive closure, which in turn allows us to define
the coherence relation $[[a <=> b]]$. % The $*$ symbol is more commonly
% used for the transitive and reflexive closure of a relation. However,
% since we can show that parallel reduction is reflexive, the transitive
% closure of parallel reduction must also be reflexive.
We say that two terms $[[a]]$
and $[[b]]$ are coherent if they can eventually reduce to some common
term $[[c]]$ through parallel reduction. The symmetric notation of
coherence suggests that it is an equivalence relation, and in fact, we
will use coherence as the equational theory for our type conversion rule.

The following lemma shows us that parallel reduction is
reflexive. As a result, we only need to take its transitive closure
for the resulting relation to also be reflexive.
\begin{lemma}[Par Refl]
  \label{lemma:parrefl}
  For all terms $[[a]]$, $[[a => a]]$.
\end{lemma}

\begin{lemma}[Pars refl]
  \label{lemma:parsrefl}
  For all terms $[[a]]$, $[[a =>+ a]]$.
\end{lemma}




A more conventional presentation would instead use full beta reduction
instead of parallel reduction as the base for the definition of
coherence. However, the diamond

\section{Semantic Typing}
\label{sec:logreldep}

\section{Consistency}
\label{sec:logrelproof}

\section{Mechanization}
\label{sec:logrelmech}

\section{Related Work}
\label{sec:relatedwork}

% Type soundness can be proven through a syntactic
% approach~\citep{syntacticsoundness} as a corollary of two properties:
% progress and preservation. % The syntactic type soundness proof
% % varies in complexity depending on the underlying type
% % system. For example, a type system that tracks information flow would
% % require additional structural rules related to security levels. In
% % this paper, we focus on one specific type of complexity: the
% In Figure~\ref{fig:stlcsoundness}, we summarize the structure of the
% syntactic type soundness proof for the simply typed lambda
% calculus. Each lemma can be proven by structural induction over the
% typing derivation, while using the previous established results as
% lemmas for specific cases that do not immediately follow from the
% induction hypothesis. If we make our language more complex by adding
% full dependent type support, the overall structure remains almost
% identical.


% NbE in Coq

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{refs}


%%
%% If your work has an appendix, this is the place to put it.

\end{document}
\endinput
%%
%% End of file `sample-acmsmall.tex'.
