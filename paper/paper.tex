%%
%% This is file `sample-acmsmall.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `acmsmall')
%%
%% IMPORTANT NOTICE:
%%
%% For the copyright see the source file.
%%
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-acmsmall.tex.
%%
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%%
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass
%% command.
%%
%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
%%
%%
\documentclass[nonacm]{acmart}
\usepackage{ottalt}
\usepackage{xspace}
\newcommand{\lang}{$\lambda^H$\xspace}
\inputott{rules}
%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
\citestyle{acmauthoryear}


%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{A Short and Mechanized Consistency Proof for Dependent Type Theory}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Yiyun Liu}
\orcid{0009-0006-8717-2498}
\affiliation{%
  \institution{University of Pennsylvania}
  \city{Philadelphia}
  \country{USA}
}
\email{liuyiyun@seas.upenn.edu}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
% \renewcommand{\shortauthors}{Trovato et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
Proof by logical relation is a powerful technique that has been used
to derive metatheoretic properties of type systems, such as
consistency and parametricity. While there exists a
plethora of introductory materials about logical relation in the
context of simply typed lambda calculus and System F, a streamlined
presentation of proof by logical relation for a dependently language
is lacking in comparison. In this paper, I present a short
consistency proof for a dependently typed language that contains a
rich set of features, including an infinite and cumulative universe
hierarchy, natural numbers, and an intensional identity type. We have
fully mechanized the consistency proof using the Coq proof assistant
in under 1000 lines of code.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Logical Relation, Dependent Types, Logical Consistency, Coq}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
% Depending on its application, we care about certain metatheoretic
% properties about a type system. As a programming language, we may care
% about type soundness, which states that a well-typed never gets stuck
% during evaluation.
When a type system is used as a program logic where terms encode proofs, we
want our type system to be logically consistent, meaning
that the empty type is not inhabited.
This paper is specifically
about establishing logical consistency for a fully dependently typed
system with an infinite universe hierarchy and support for large
elimination. % The type system, presented in Section~\ref{sec:spec}, is
% most similar to Martin-Lof's predicate type theory with the minor
% difference that type conversion is based on untyped equality.

The proof of various dependently typed systems, including Martin-Lof's
type theory, has long been
established in the literature and therefore the consistency result of
this paper is not novel. Rather,
our goal is to present the proof in a form that is digestable by a
working type theorist and can be more readily mechanized in a proof
assistant. Compared to existing efforts at mechanizing logical
consistency or stronger properties such as existence of normal
form~\citep{nbeincoq},
decidable type checking~\citep{decagda}, our work is minimal since it requires very
little scaffolding and therefore results in an extremely succinct
proof of under 1000 lines of manually written Coq code for a dependent
type theory that is reasonably complete in its features.

The key technique that underlies our consistency proof is proof by
logical relation. In Section~\ref{sec:logrelstlc}, we review the
technique in the context of the simply typed lambda calculus. In
Section~\ref{sec:spec}, we present the dependent type theory of
interest. In Section~\ref{sec:logreldep}, we give the definition
of the logical relation for the dependent type theory. Rather than
presenting the logical relation as an inductive-recursive definition,
we use the more elementary concept of a partial function to capture
the interpretation of types. The alternative representation requires us
to show that the set of equations indeed defines a partial function;
that is, for each input, there should always be a unique
output.
From the interpretation function, we can define the semantic
typing judgment for the set of lambda terms.
In Section~\ref{sec:logrelproof}, we prove the fundamental lemma,
which states that syntactic typing implies semantic typing. Once the
fundamental lemma is established, logical consistency follows as a
trivial corollary.

The downside of a pen and paper proof is that the validity of the
definitions themselves can be dubious at times. When working with a
dependent type theory that has a universe hierarchy, an intuitive
understanding of naive set theory no longer suffices as the size of
sets matters. For example, the partial function representing the
interpretation of types does not immediately correspond to a valid
definition in a proof assistant. We cannot easily define it as a
function as proof assistants such as Coq and Agda only accept total
functions. We cannot naively encode the interpretation function as an
inductive relation either since we violate the strict positivity
constraint. A detailed discussion of how we work around such technical
issues can be distracting. However, what can be equally distracting is
following along a proof where even the validity of the statement is
not trusted. As a result, we clearly mark the ``suspicious''
definitions, and defer the discussion of these definitions
until Section~\ref{sec:logrelmech}, where we give an overview of our
short Coq mechanization proof and the various proof engineering
techniques we adopt to make the mechanization for tractable.

Finally, in Section~\ref{sec:relatedwork}, we give a short survey of
existing literature related to logical consistency about dependent
type theory.

\section{Review of Proof by Logical Relation}
\label{sec:logrelstlc}
In this section, we give a quick review of the consistency proof of the
simply typed lambda calculus augmented with the empty type through
proof by logical relation.

We give the full specification of the simply typed calculus in
Figure~\ref{fig:stlcsyntax},\ref{fig:stlctyping},\ref{fig:stlcdynamics}
without any further explanation since it is standard.

The goal here is to show that the empty type cannot be
inhabited. A naive attempt at proof by structural induction


\section{Specification of a Dependent Type Theory}
\label{sec:spec}

\begin{figure}[h]
\[
\begin{array}{lcll}
\mathit{Natural\ numbers}\\
[[i]],[[j]],[[n]] & ::= & [[0]]\ |\ [[S i]] & \mbox{zero, successor} \\ \\

\mathit{Contexts}\\
[[G]]       & ::= & [[empty]]\ |\ [[G ++ A]] &  \\ \\
\mathit{Terms}\\
[[a]],[[b]],[[c]],[[t]],[[p]],[[A]],[[B]] & ::= & [[Set i]]\ |\ [[i]]\  |\ [[Void]]
                  & \mbox{universes, variables, empty type} \\
            & |   & [[Pi A B]]\ |\ [[\ A a]]\ |\ [[a b]]
                  & \mbox{function types, abstractions, applications} \\
            & |   & [[a ~ b : A ]]\ |\  [[refl]]\ |\ [[J t a b p]]
                  & \mbox{equality types, reflexivity proof, J eliminator} \\
            & |   & [[Bool]]\ |\  [[true]]\ |\  [[false]]\ |\  [[if a b0 b1]]
                  & \mbox{boolean type, true, false, if}
\end{array}
\]
  \caption{Syntax of \lang}
  \label{fig:syntax}
\end{figure}


\begin{figure}[h]
\drules[P]{$[[a => b]]$}{Parallel Reduction}{Var, Set, Void, Pi, Abs, App, AppAbs, True, False, If, IfTrue, IfFalse, Bool, Eq, Refl, J, JRefl}
\drules[PS]{$[[a =>+ b]]$}{Transitive Closure of Parallel Reduction}{One, Step}
\drules[C]{$[[a <=> b]]$}{Coherence}{Intro}
\caption{Parallel reduction and coherence}
\label{fig:par}
\end{figure}

\begin{figure}[h]
\drules[Ctx]{$[[ |- G]]$}{Context Well-Formedness}{Empty, Cons}
\drules[T]{$[[G |-  a : A]]$}{Typing}{Var, Set, Pi, Abs, App, Conv, Refl, J, Bool, True, False, If, Void}
\caption{Syntactic typing for \lang}
\label{fig:typing}
\end{figure}


In this section, we present the dynamics and statics of the
dependent type theory whose logical consistency will be proven in
Section~\ref{sec:logrelproof}. For concision, we refer to this system
as \lang.

The syntax of \lang can be found in Figure~\ref{fig:syntax}. As a
dependent type theory, terms and types are collapsed into the same
syntactic category. Dependent functions take the form $[[Pi A B]]$ and
we use the notation $[[A -> B]]$ when the output type $[[B]]$ is not
dependent on the input variable. $[[Set i]]$ represents the universe
type where $[[i]]$ ranges over the set of natural numbers. Finally,
\lang also includes an intensional identity type $[[a ~ b : A]]$ whose
proofs can be eliminated by the J-eliminator $[[J t a b p]]$, where
$[[p]]$ is an equality proof between $[[a]]$ and $[[b]]$, and $[[t]]$
is the term whose type is to be casted.

\lang is expressive enough to support large
elimination, the ability to compute a type using a term as input. For
example, the function $[[\ Bool if 0 Bool Bool -> Bool]]$ returns
either $[[Bool]]$ or $[[Bool -> Bool]]$ depending on whether the input
is $[[true]]$ or $[[false]]$.

Figure~\ref{fig:par} shows the definition of the parallel reduction
relation, which takes the form $[[a => b]]$. We use $[[a =>+ b]]$ to
represent its transitive closure, which in turn allows us to define
the coherence relation $[[a <=> b]]$. % The $*$ symbol is more commonly
% used for the transitive and reflexive closure of a relation. However,
% since we can show that parallel reduction is reflexive, the transitive
% closure of parallel reduction must also be reflexive.
We say that two terms $[[a]]$
and $[[b]]$ are coherent if they can eventually reduce to some common
term $[[c]]$ through parallel reduction. The symmetric notation of
coherence suggests that it is an equivalence relation, and in fact, we
will use coherence as the equational theory for our type conversion
rule. Now, we prove that coherence is indeed an equivalence relation.

First, we show that coherence is reflexive through the following
sequence of lemmas.
\begin{lemma}[Par Refl]
  \label{lemma:parrefl}
  For all terms $[[a]]$, $[[a => a]]$.
\end{lemma}

\begin{lemma}[Pars refl]
  \label{lemma:parsrefl}
  For all terms $[[a]]$, $[[a =>+ a]]$.
\end{lemma}

\begin{lemma}[Coherence refl]
  \label{lemma:coherencerefl}
  For all terms $[[a]]$, $[[a <=> a]]$.
\end{lemma}

Lemma~\ref{lemma:parrefl} can be proven by structural induction over
the term $[[a]]$. Lemmas~\ref{lemma:parsrefl} and \ref{lemma:coherencerefl}
immediately follow as corollaries of Lemma~\ref{lemma:parrefl}.

Symmetry of coherence immediately falls from its definition.
\begin{lemma}[Coherence sym]
  \label{lemma:coherencesym}
  If $[[a <=> b]]$, then $[[b <=> a]]$.
\end{lemma}

Before we can prove transitivity, we need to show that parallel
reduction satisfies the diamond property.
\begin{lemma}[Par cong]
  \label{lemma:parcong}
  If $[[a0 => a1]]$ and $[[b0 => b1]]$, then $[[a0 { b0 } => a1 { b1 }]]$.
\end{lemma}
\begin{lemma}[Par diamond]
  \label{lemma:pardiamond}
  If $[[a => b0]]$ and $[[a => b1]]$, then there exists some term
  $[[c]]$ such that $[[b0 => c]]$ and $[[b1 => c]]$.
\end{lemma}
The congruence property (Lemma~\ref{lemma:parcong}) can be proven by
structural induction over the derivation of $[[a0 => a1]]$.
Likewise, Lemma~\ref{lemma:pardiamond} can be proven by structural induction
over the derivation of $[[a => b0]]$. The \rref{P-AppAbs} case requires
the use of Lemma~\ref{lemma:parcong}.

From Lemma~\ref{lemma:parcong} and \ref{lemma:parrefl}, we recover the
single substitution property as a simple corollary.
\begin{corollary}[Par subst]
  \label{lemma:parsubst}
  If $[[a0 => a1]]$, then $[[a0 {b} => a1 {b}]]$ for arbitrary $[[b]]$.
\end{corollary}


A relation that satisfies the
diamond property must also be confluent, meaning that its transitive
and reflexive closure is confluent.
\begin{lemma}[Par confluent]
  \label{lemma:parconfluent}
  If $[[a =>+ b0]]$ and $[[a =>+ b1]]$, then there exists some term
  $[[c]]$ such that $[[b0 =>+ c]]$ and $[[b1 =>+ c]]$.
\end{lemma}
While $[[a =>+ b]]$ is defined as the transitive closure of $[[a => b]]$,
it coincides with the transitive and reflexive closure of $[[a => b]]$ since $[[a
=> b]]$ is reflexive (Lemma~\ref{lemma:parrefl}).

The transitivity of the coherence relation follows as a corollary of
Lemma~\ref{lemma:parconfluent}.
\begin{lemma}[Coherence trans]
  \label{lemma:coherencetrans}
  If $[[a0 <=> a1]]$ and $[[a1 <=> a2]]$, then $[[a0 <=> a2]]$.
\end{lemma}
By the definition of coherence, there exists some term $[[b]]$ such that $[[a0 =>+ b0]]$,
$[[a1 =>+ b0]]$ and some term $[[b1]]$ such that $[[a1 =>+ b1]]$ and
$[[a2 =>+ b1]]$. By Lemma~\ref{lemma:parconfluent}, there exists some
term $[[c]]$ such that $[[b0 =>+ c]]$ and $[[b1 =>+ c]]$. It sufficies
to show that $[[a0 =>+ c]]$ and $[[a2 =>+ c]]$, both of which
trivially hold since the transitive closure $[[a =>+ b]]$ is transitive.
This concludes the proof that coherence is an equivalence relation.
\begin{lemma}[Coherence Equivalence]
  \label{lemma:coherenceequiv}
  The relation $[[a <=> b]]$ satisfies reflexivity, symmetry, and
  transitivity and therefore is an equivalence relation.
\end{lemma}

We note that a more conventional presentation of
\rref{T-Conv} would instead use full beta reduction as the base for
the definition of coherence. However, since full beta reduction
doesn't satisfy the diamond property, one typically needs parallel
reduction as an auxilliary definition to derive the confluence of full
beta reduction. The formulation of \lang is slightly more economical.

\section{Semantic Typing}
\label{sec:logreldep}
\begin{figure}[h]
\drules[I]{$[[Interp I i A S]]$}{Logical Relation}{Void, Bool, Eq, Pi, Set, Red}
\caption{Logical relation for \lang}
\label{fig:logrel}
\end{figure}
In this section, we define the logical relation for \lang{} in the
form of an inductively defined relation (Figure~\ref{fig:logrel}). The
logical relation takes the form $[[Interp I i A S]]$. The
metavariables $[[A]]$ and $[[i]]$ stand for terms and natural
numbers respectively, as introduced earlier in
Figure~\ref{fig:syntax}.
The metavariables $[[I]]$ and $[[S]]$ are
sets with the following signatures:
\begin{equation*}
  \begin{split}
    [[I]] &\in [[ { j | j < i  } ->  PowerSet STm ]] \\
    [[S]] &\in [[PowerSet STm]]
  \end{split}
\end{equation*}
The function $[[I]]$ is a family of subsets of terms indexed by
natural numbers strictly less than the parameter $[[i]]$, which
represents the current universe level.  In \rref{I-Set}, function
$[[I]]$ is used to define the meaning of
universes that are strictly smaller than the current level $[[i]]$. The
restriction $[[j < i]]$ in \rref{I-Set} is crucial for our system to
be predicative. Removing the ordering constraint would result in a
system where one can encode Girard's paradox~\citep{girard-thesis}.

\begin{figure}[h]
\begin{equation*}
  \begin{split}
    [[InterpR i A S]] &:= [[ Interp F i A S  ]] \\
    [[F i]] &:= [[exists S , InterpR i A S]]
  \end{split}
\end{equation*}
\caption{Logical relation for all universe levels}
\label{fig:logrelrec}
\end{figure}
To tie the knot and obtain an interpretation of all universe levels,
we define in Figure~\ref{fig:logrelrec} the final version of our interpretation judgment recursively
using the well-foundedness of the strict less than relation on natural
numbers.
The judgment $[[InterpR i A S]]$ now reads that the type $[[A]]$ is a
level-$[[i]]$ type \emph{semantically} inhabited by terms from the set
$[[S]]$. The way it's constructed enables us to reason about its
property by nested induction over the less than relation and the
structure of the relation $[[Interp I i A S]]$, though for the
majority of the cases we do not need any information about the
parameterized function $[[I]]$, where the property about $[[InterpR i
A S]]$ follows as a corollary of a property about $[[Interp I i A S]]$
with no assumptions imposed on $[[I]]$.

For the rest of the section, we establish some important facts about
the logical relation that will be useful for proving fundamental lemma
in Section~\ref{sec:logrelproof}.

The relation $[[Interp I i A S]]$ satisfies the following inversion
principles.
\begin{lemma}[Inversion of the logical relation]
  \label{lemma:interpinv}\leavevmode
  \begin{enumerate}
  \item If $[[Interp I i Void S]]$, then $[[S = emptyset]]$.
  \item If $[[Interp I i Bool S]]$, then $[[S = { a | a =>+ true \/ a =>+ false   }]]$.
  \item If $[[Interp I i a ~ b : A S]]$, then $[[S = { p | p =>+ refl , a <=> b  }]]$.
  \item If $[[Interp I i Pi A B S]]$, then there exists $[[S]],[[F]]$ such that:
    \begin{itemize}
    \item $[[Interp I i A S ]]$
    \item $[[F in S -> PowerSet STm]]$
    \item $[[forall a, (# a in S implies Interp I i B { a } F a #)]]$
    \end{itemize}
  \item If $[[Interp I i Set j S]]$, then $[[j < i]]$ and $[[S = I j]]$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  We only show the most involved function case; the rest follows a
  similar but simpler pattern. We start by
  inducting over the derivation of $[[Interp I i Pi A B S]]$. There
  are only two possible cases we need to consider.
  \begin{description}
  \item[\Rref{I-Pi}:] Immediate.
  \item[\Rref{I-Red}:] We know that there exists some $[[A0]]$ and
    $[[B0]]$ such that $[[Pi A B => Pi A0 B0]]$, and from the
    induction hypothesis, there exists $[[S]]$ and $[[F]]$ such that :
    \begin{itemize}
    \item $[[Interp I i A0 S ]]$
    \item $[[F in S -> PowerSet STm]]$
    \item $[[forall a, (# a in S implies Interp I i B0 { a } F a #)]]$
    \end{itemize}
    By inverting $[[Pi A B => Pi A0 B0]]$, we derive $[[A => A0]]$ and
    $[[B => B0]]$. By Lemma~\ref{lemma:parsubst}, we have $[[B {a} => B0 {a} ]]$ for all
    $[[a]]$. As a result, by \rref{I-Red}, the same $[[S]]$ and
    $[[F]]$ satisfies the desired properties:
    \begin{itemize}
    \item $[[Interp I i A S ]]$
    \item $[[F in S -> PowerSet STm]]$
    \item $[[forall a, (# a in S implies Interp I i B { a } F a #)]]$
    \end{itemize}
  \end{description}
\end{proof}

\Rref{I-Red} bakes into the logical relation the backward preservation
property. The following property shows that preservation holds in the
usual forward direction too.
\begin{lemma}[Preservation of the logical relation]
  \label{lemma:interppreservation}
  If $[[Interp I i A S]]$ and $[[A => B]]$, then $[[Interp I i B S]]$.
\end{lemma}
\begin{proof}
  We carry out the proof by induction over the derivation of $[[Interp
  I i A S]]$.
  \begin{description}
  \item[\Rref{I-Void}:] There exists some $[[B]]$ such that $[[Void =>
    B]]$. By inverting the derivation of $[[Void => B]]$, $[[B]]$ must
    be $[[Void]]$ and the result trivially follows.
  \item[\Rref{I-Bool, I-Set}:] Similar to the case for \rref{I-Void}.
  \item[\Rref{I-Eq}:] We know that $[[Interp I i a ~ b : A { p | p =>+
      refl , a <=> b  }]]$ and, by inverting the derivation of
    parallel reduction, $[[a => a0]]$, $[[b => b0]]$, $[[A => A0]]$
    for some $[[a0]]$, $[[b0]]$, and $[[A0]]$. Our goal is to show
    that $[[Interp I i a0 ~ b0 : A {p | p =>+ refl, a <=> b}]]$. By
    \rref{I-Eq}, we already know that $[[Interp I i a0 ~ b0 : A {p | p
      =>+ refl, a0 <=> b0}]]$ and therefore it suffices to show that
    the sets $[[{p | p =>+ refl, a <=> b}]]$ and $[[{p | p =>+ refl,
      a0 <=> b0}]]$ are equal. Equivalently, it suffices to show that
    $[[a <=> b]]$ if and only if $[[a0 <=> b0]]$. By definition, from
    $[[a => a0]]$ and $[[b => b0]]$, we derive $[[a <=> a0]]$ and $[[b
    <=> b0]]$. The result then immediately follows from the fact that
    coherence is an equivalence relation
    (Lemma~\ref{lemma:coherenceequiv}).
  \item[\Rref{I-Pi}:]
  \end{description}
\end{proof}

\section{Consistency}
\label{sec:logrelproof}

\section{Mechanization}
\label{sec:logrelmech}

\section{Related Work}
\label{sec:relatedwork}

% Type soundness can be proven through a syntactic
% approach~\citep{syntacticsoundness} as a corollary of two properties:
% progress and preservation. % The syntactic type soundness proof
% % varies in complexity depending on the underlying type
% % system. For example, a type system that tracks information flow would
% % require additional structural rules related to security levels. In
% % this paper, we focus on one specific type of complexity: the
% In Figure~\ref{fig:stlcsoundness}, we summarize the structure of the
% syntactic type soundness proof for the simply typed lambda
% calculus. Each lemma can be proven by structural induction over the
% typing derivation, while using the previous established results as
% lemmas for specific cases that do not immediately follow from the
% induction hypothesis. If we make our language more complex by adding
% full dependent type support, the overall structure remains almost
% identical.


% NbE in Coq

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{refs}


%%
%% If your work has an appendix, this is the place to put it.

\end{document}
\endinput
%%
%% End of file `sample-acmsmall.tex'.
