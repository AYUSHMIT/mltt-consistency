%%
%% This is file `sample-acmsmall.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `acmsmall')
%%
%% IMPORTANT NOTICE:
%%
%% For the copyright see the source file.
%%
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-acmsmall.tex.
%%
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%%
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass
%% command.
%%
%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
%%
%%
\documentclass[nonacm]{acmart}
\usepackage{ottalt}
\usepackage{xspace}
\newcommand{\lang}{$\lambda^H$\xspace}
\inputott{rules}
%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
\citestyle{acmauthoryear}


%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{A Short and Mechanized Consistency Proof for Dependent Type Theory}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Yiyun Liu}
\orcid{0009-0006-8717-2498}
\affiliation{%
  \institution{University of Pennsylvania}
  \city{Philadelphia}
  \country{USA}
}
\email{liuyiyun@seas.upenn.edu}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
% \renewcommand{\shortauthors}{Trovato et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
Proof by logical relation is a powerful technique that has been used
to derive metatheoretic properties of type systems, such as
consistency and parametricity. While there exists a
plethora of introductory materials about logical relation in the
context of simply typed lambda calculus and System F, a streamlined
presentation of proof by logical relation for a dependently language
is lacking in comparison. In this paper, I present a short
consistency proof for a dependently typed language that contains a
rich set of features, including an infinite and cumulative universe
hierarchy, natural numbers, and an intensional identity type. We have
fully mechanized the consistency proof using the Coq proof assistant
in under 1000 lines of code.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Logical Relation, Dependent Types, Logical Consistency, Coq}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
% Depending on its application, we care about certain metatheoretic
% properties about a type system. As a programming language, we may care
% about type soundness, which states that a well-typed never gets stuck
% during evaluation.
When a type system is used as a program logic where terms encode proofs, we
want our type system to be logically consistent, meaning
that the empty type is not inhabited.
This paper is specifically
about establishing logical consistency for a fully dependently typed
system with an infinite universe hierarchy and support for large
elimination. % The type system, presented in Section~\ref{sec:spec}, is
% most similar to Martin-Lof's predicate type theory with the minor
% difference that type conversion is based on untyped equality.

The proof of various dependently typed systems, including Martin-Lof's
type theory, has long been
established in the literature and therefore the consistency result of
this paper is not novel. Rather,
our goal is to present the proof in a form that is digestable by a
working type theorist and can be more readily mechanized in a proof
assistant. Compared to existing efforts at mechanizing logical
consistency or stronger properties such as existence of normal
form~\citep{nbeincoq},
decidable type checking~\citep{decagda}, our work is minimal since it requires very
little scaffolding and therefore results in an extremely succinct
proof of under 1000 lines of manually written Coq code for a dependent
type theory that is reasonably complete in its features.

The key technique that underlies our consistency proof is proof by
logical relation. In
Section~\ref{sec:spec}, we present the dependent type theory of
interest. In Section~\ref{sec:logreldep}, we give the definition
of the logical relation for the dependent type theory. Rather than
presenting the logical relation as an inductive-recursive definition,
we use the more elementary concept of a partial function to capture
the interpretation of types. The alternative representation requires us
to show that the set of equations indeed defines a partial function;
that is, for each input, there should always be a unique
output.
From the interpretation function, we can define the semantic
typing judgment for the set of lambda terms.
In Section~\ref{sec:logrelproof}, we prove the fundamental lemma,
which states that syntactic typing implies semantic typing. Once the
fundamental lemma is established, logical consistency follows as a
trivial corollary.

The downside of a pen and paper proof is that the validity of the
definitions themselves can be dubious at times. When working with a
dependent type theory that has a universe hierarchy, an intuitive
understanding of naive set theory no longer suffices as the size of
sets matters. For example, the partial function representing the
interpretation of types does not immediately correspond to a valid
definition in a proof assistant. We cannot easily define it as a
function as proof assistants such as Coq and Agda only accept total
functions. We cannot naively encode the interpretation function as an
inductive relation either since we violate the strict positivity
constraint. A detailed discussion of how we work around such technical
issues can be distracting. However, what can be equally distracting is
following along a proof where even the validity of the statement is
not trusted. As a result, we clearly mark the ``suspicious''
definitions, and defer the discussion of these definitions
until Section~\ref{sec:logrelmech}, where we give an overview of our
short Coq mechanization proof and the various proof engineering
techniques we adopt to make the mechanization for tractable.

Finally, in Section~\ref{sec:relatedwork}, we give a short survey of
existing literature related to logical consistency about dependent
type theory.

\section{Specification of a Dependent Type Theory}
\label{sec:spec}

\begin{figure}[h]
\[
\begin{array}{lcll}
\mathit{Natural\ numbers}\\
[[i]],[[j]],[[n]] & ::= & [[0]]\ |\ [[S i]] & \mbox{zero, successor} \\ \\

\mathit{Contexts}\\
[[G]]       & ::= & [[empty]]\ |\ [[G ++ A]] &  \\ \\
\mathit{Terms}\\
[[a]],[[b]],[[c]],[[t]],[[p]],[[A]],[[B]] & ::= & [[Set i]]\ |\ [[i]]\  |\ [[Void]]
                  & \mbox{universes, variables, empty type} \\
            & |   & [[Pi A B]]\ |\ [[\ A a]]\ |\ [[a b]]
                  & \mbox{function types, abstractions, applications} \\
            & |   & [[a ~ b : A ]]\ |\  [[refl]]\ |\ [[J t a b p]]
                  & \mbox{equality types, reflexivity proof, J eliminator} \\
            & |   & [[Bool]]\ |\  [[true]]\ |\  [[false]]\ |\  [[if a b0 b1]]
                  & \mbox{boolean type, true, false, if}
\end{array}
\]
  \caption{Syntax of \lang}
  \label{fig:syntax}
\end{figure}


\begin{figure}[h]
\drules[P]{$[[a => b]]$}{Parallel Reduction}{Var, Set, Void, Pi, Abs, App, AppAbs, True, False, If, IfTrue, IfFalse, Bool, Eq, Refl, J, JRefl}
\drules[PS]{$[[a =>+ b]]$}{Transitive Closure of Parallel Reduction}{One, Step}
\drules[C]{$[[a <=> b]]$}{Coherence}{Intro}
\caption{Parallel reduction and coherence}
\label{fig:par}
\end{figure}

\begin{figure}[h]
\drules[Ctx]{$[[ |- G]]$}{Context Well-Formedness}{Empty, Cons}
\drules[T]{$[[G |-  a : A]]$}{Typing}{Var, Set, Pi, Abs, App, Conv, Refl, J, Bool, True, False, If, Void}
\caption{Syntactic typing for \lang}
\label{fig:typing}
\end{figure}


In this section, we present the dynamics and statics of the
dependent type theory whose logical consistency will be proven in
Section~\ref{sec:logrelproof}. For concision, we refer to this system
as \lang.

The syntax of \lang can be found in Figure~\ref{fig:syntax}. As a
dependent type theory, terms and types are collapsed into the same
syntactic category. Dependent functions take the form $[[Pi A B]]$ and
we use the notation $[[A -> B]]$ when the output type $[[B]]$ is not
dependent on the input variable. $[[Set i]]$ represents the universe
type where $[[i]]$ ranges over the set of natural numbers.
 Finally,
\lang also includes an intensional identity type $[[a ~ b : A]]$ whose
proofs can be eliminated by the J-eliminator $[[J t a b p]]$, where
$[[p]]$ is an equality proof between $[[a]]$ and $[[b]]$, and $[[t]]$
is the term whose type is to be casted.

\lang is expressive enough to support large
elimination, the ability to compute a type using a term as input. For
example, the function $[[\ Bool if 0 Bool Bool -> Bool]]$ returns
either $[[Bool]]$ or $[[Bool -> Bool]]$ depending on whether the input
is $[[true]]$ or $[[false]]$.

Figure~\ref{fig:par} shows the definition of the parallel reduction
relation, which takes the form $[[a => b]]$. We use $[[a =>+ b]]$ to
represent its transitive closure, which in turn allows us to define
the coherence relation $[[a <=> b]]$. % The $*$ symbol is more commonly
% used for the transitive and reflexive closure of a relation. However,
% since we can show that parallel reduction is reflexive, the transitive
% closure of parallel reduction must also be reflexive.
We say that two terms $[[a]]$
and $[[b]]$ are coherent if they can eventually reduce to some common
term $[[c]]$ through parallel reduction. The symmetric notation of
coherence suggests that it is an equivalence relation, and in fact, we
will use coherence as the equational theory for our type conversion
rule. Now, we prove that coherence is indeed an equivalence relation.

First, we show that coherence is reflexive through the following
sequence of lemmas.
\begin{lemma}[Par Refl]
  \label{lemma:parrefl}
  For all terms $[[a]]$, $[[a => a]]$.
\end{lemma}

\begin{lemma}[Pars refl]
  \label{lemma:parsrefl}
  For all terms $[[a]]$, $[[a =>+ a]]$.
\end{lemma}

\begin{lemma}[Coherence refl]
  \label{lemma:coherencerefl}
  For all terms $[[a]]$, $[[a <=> a]]$.
\end{lemma}

Lemma~\ref{lemma:parrefl} can be proven by structural induction over
the term $[[a]]$. Lemmas~\ref{lemma:parsrefl} and \ref{lemma:coherencerefl}
immediately follow as corollaries of Lemma~\ref{lemma:parrefl}.

Symmetry of coherence immediately falls from its definition.
\begin{lemma}[Coherence sym]
  \label{lemma:coherencesym}
  If $[[a <=> b]]$, then $[[b <=> a]]$.
\end{lemma}

Before we can prove transitivity, we need to show that parallel
reduction satisfies the diamond property.
\begin{lemma}[Par cong]
  \label{lemma:parcong}
  If $[[a0 => a1]]$ and $[[b0 => b1]]$, then $[[a0 { b0 } => a1 { b1 }]]$.
\end{lemma}
\begin{lemma}[Par diamond]
  \label{lemma:pardiamond}
  If $[[a => b0]]$ and $[[a => b1]]$, then there exists some term
  $[[c]]$ such that $[[b0 => c]]$ and $[[b1 => c]]$.
\end{lemma}
The congruence property (Lemma~\ref{lemma:parcong}) can be proven by
structural induction over the derivation of $[[a0 => a1]]$.
Likewise, Lemma~\ref{lemma:pardiamond} can be proven by structural induction
over the derivation of $[[a => b0]]$. The \rref{P-AppAbs} case requires
the use of Lemma~\ref{lemma:parcong}.

From Lemma~\ref{lemma:parcong} and \ref{lemma:parrefl}, we recover the
single substitution property as a simple corollary.
\begin{corollary}[Par subst]
  \label{lemma:parsubst}
  If $[[a0 => a1]]$, then $[[a0 {b} => a1 {b}]]$ for arbitrary $[[b]]$.
\end{corollary}


A relation that satisfies the
diamond property must also be confluent, meaning that its transitive
and reflexive closure is confluent.
\begin{lemma}[Par confluent]
  \label{lemma:parconfluent}
  If $[[a =>+ b0]]$ and $[[a =>+ b1]]$, then there exists some term
  $[[c]]$ such that $[[b0 =>+ c]]$ and $[[b1 =>+ c]]$.
\end{lemma}
While $[[a =>+ b]]$ is defined as the transitive closure of $[[a => b]]$,
it coincides with the transitive and reflexive closure of $[[a => b]]$ since $[[a
=> b]]$ is reflexive (Lemma~\ref{lemma:parrefl}).

The transitivity of the coherence relation follows as a corollary of
Lemma~\ref{lemma:parconfluent}.
\begin{lemma}[Coherence trans]
  \label{lemma:coherencetrans}
  If $[[a0 <=> a1]]$ and $[[a1 <=> a2]]$, then $[[a0 <=> a2]]$.
\end{lemma}
By the definition of coherence, there exists some term $[[b]]$ such that $[[a0 =>+ b0]]$,
$[[a1 =>+ b0]]$ and some term $[[b1]]$ such that $[[a1 =>+ b1]]$ and
$[[a2 =>+ b1]]$. By Lemma~\ref{lemma:parconfluent}, there exists some
term $[[c]]$ such that $[[b0 =>+ c]]$ and $[[b1 =>+ c]]$. It sufficies
to show that $[[a0 =>+ c]]$ and $[[a2 =>+ c]]$, both of which
trivially hold since the transitive closure $[[a =>+ b]]$ is transitive.
This concludes the proof that coherence is an equivalence relation.
\begin{lemma}[Coherence Equivalence]
  \label{lemma:coherenceequiv}
  The relation $[[a <=> b]]$ satisfies reflexivity, symmetry, and
  transitivity and therefore is an equivalence relation.
\end{lemma}

We note that a more conventional presentation of
\rref{T-Conv} would instead use full beta reduction as the base for
the definition of coherence. However, since full beta reduction
doesn't satisfy the diamond property, one typically needs parallel
reduction as an auxilliary definition to derive the confluence of full
beta reduction. The formulation of \lang is slightly more economical.

\section{Logical Relation}
\label{sec:logreldep}
\begin{figure}[h]
\drules[I]{$[[Interp I i A S]]$}{Logical Relation}{Void, Bool, Eq, Pi, Set, Red}
\caption{Logical relation for \lang}
\label{fig:logrel}
\end{figure}
In this section, we define the logical relation for \lang{} in the
form of an inductively defined relation (Figure~\ref{fig:logrel}). The
logical relation takes the form $[[Interp I i A S]]$. The
metavariables $[[A]]$ and $[[i]]$ stand for terms and natural
numbers respectively, as introduced earlier in
Figure~\ref{fig:syntax}.
The metavariables $[[I]]$ and $[[S]]$ are
sets with the following signatures:
\begin{equation*}
  \begin{split}
    [[I]] &\in [[ { j | j < i  } ->  PowerSet STm ]] \\
    [[S]] &\in [[PowerSet STm]]
  \end{split}
\end{equation*}
The function $[[I]]$ is a family of subsets of terms indexed by
natural numbers strictly less than the parameter $[[i]]$, which
represents the current universe level.  In \rref{I-Set}, function
$[[I]]$ is used to define the meaning of
universes that are strictly smaller than the current level $[[i]]$. The
restriction $[[j < i]]$ in \rref{I-Set} is crucial for our system to
be predicative. Removing the ordering constraint would result in a
system where one can encode Girard's paradox~\citep{girard-thesis}.

\begin{figure}[h]
\begin{equation*}
    [[InterpR i A S]] := [[ Interp I i A S  ]], \text{where } [[I i]] := [[{A | exists S , InterpR i A S}]]
\end{equation*}
\caption{Logical relation for all universe levels}
\label{fig:logrelrec}
\end{figure}
To tie the knot and obtain an interpretation of all universe levels,
we define in Figure~\ref{fig:logrelrec} the final version of our interpretation judgment recursively
using the well-foundedness of the strict less than relation on natural
numbers (recall that
the parameter $[[I]]$ of $[[Interp I i A S]]$ takes only natural
numbers strictly less than $[[i]]$ as its input).
The judgment $[[InterpR i A S]]$ now reads that the type $[[A]]$ is a
level-$[[i]]$ type \emph{semantically} inhabited by terms from the set
$[[S]]$. For the
majority of the properties we are about to prove in this section, we
do not need any information about the parameterized function $[[I]]$.
Each property about $[[InterpR i A S]]$ follows as a corollary of
a property about $[[Interp I i A S]]$ with no or few assumptions imposed on
$[[I]]$. As a result, we usually state our lemmas in terms of
$[[Interp I i A S]]$ without duplicating them in terms of $[[InterpR i
A S]]$.

For the rest of the section, we establish some important facts about
the logical relation that will be useful for proving fundamental lemma
in Section~\ref{sec:logrelproof}.

The relation $[[Interp I i A S]]$ satisfies the following inversion
principles.
\begin{lemma}[Inversion of the logical relation]
  \label{lemma:interpinv}\leavevmode
  \begin{enumerate}
  \item If $[[Interp I i Void S]]$, then $[[S = emptyset]]$.
  \item If $[[Interp I i Bool S]]$, then $[[S = { a | a =>+ true \/ a =>+ false   }]]$.
  \item If $[[Interp I i a ~ b : A S]]$, then $[[S = { p | p =>+ refl , a <=> b  }]]$.
  \item If $[[Interp I i Pi A B S0]]$, then there exists $[[S]],[[F]]$ such that:
    \begin{itemize}
    \item $[[Interp I i A S ]]$
    \item $[[F in S -> PowerSet STm]]$
    \item $[[forall a, (# a in S implies Interp I i B { a } F a #)]]$
    \item $[[S0 = { b | forall a, (# a in S implies b a in F a #) }]]$
    \end{itemize}
  \item If $[[Interp I i Set j S]]$, then $[[j < i]]$ and $[[S = I j]]$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  We only show the most involved function case; the rest follows a
  similar but simpler pattern. We start by
  inducting over the derivation of $[[Interp I i Pi A B S]]$. There
  are only two possible cases we need to consider.
  \begin{description}
  \item[\Rref{I-Pi}:] Immediate.
  \item[\Rref{I-Red}:] We are given that $[[Interp I i Pi A B S0]]$.
    We know that there exists some $[[A0]]$ and
    $[[B0]]$ such that $[[Pi A B => Pi A0 B0]]$ and $[[Interp I i Pi
    A0 B0 S0]]$. From the
    induction hypothesis, there exists $[[S]]$ and $[[F]]$ such that :
    \begin{itemize}
    \item $[[Interp I i A0 S ]]$
    \item $[[F in S -> PowerSet STm]]$
    \item $[[forall a, (# a in S implies Interp I i B0 { a } F a #)]]$
    \item $[[S0 = { b | forall a, (# a in S implies b a in F a #) }]]$
    \end{itemize}
    By inverting $[[Pi A B => Pi A0 B0]]$, we derive $[[A => A0]]$ and
    $[[B => B0]]$. By Lemma~\ref{lemma:parsubst}, we have $[[B {a} => B0 {a} ]]$ for all
    $[[a]]$. As a result, by \rref{I-Red}, the same $[[S]]$ and
    $[[F]]$ satisfies the following properties:
    \begin{itemize}
    \item $[[Interp I i A S ]]$
    \item $[[F in S -> PowerSet STm]]$
    \item $[[forall a, (# a in S implies Interp I i B { a } F a #)]]$
    \end{itemize}
    The properties above are exactly the preconditions needed to apply
    \rref{I-Pi} for $[[Pi A B]]$ to finish off the proof.
  \end{description}
\end{proof}

\Rref{I-Red} bakes into the logical relation the backward preservation
property. The following property shows that preservation holds in the
usual forward direction too.
\begin{lemma}[Preservation of the logical relation]
  \label{lemma:interppreservation}
  If $[[Interp I i A S]]$ and $[[A => B]]$, then $[[Interp I i B S]]$.
\end{lemma}
\begin{proof}
  We carry out the proof by induction over the derivation of $[[Interp
  I i A S]]$.
  \begin{description}
  \item[\Rref{I-Void}:] There exists some $[[B]]$ such that $[[Void =>
    B]]$. By inverting the derivation of $[[Void => B]]$, $[[B]]$ must
    be $[[Void]]$ and the result trivially follows.
  \item[\Rref{I-Bool, I-Set}:] Similar to the case for \rref{I-Void}.
  \item[\Rref{I-Eq}:] We know that $[[Interp I i a ~ b : A { p | p =>+
      refl , a <=> b  }]]$ and, by inverting the derivation of
    parallel reduction, $[[a => a0]]$, $[[b => b0]]$, $[[A => A0]]$
    for some $[[a0]]$, $[[b0]]$, and $[[A0]]$. Our goal is to show
    that $[[Interp I i a0 ~ b0 : A {p | p =>+ refl, a <=> b}]]$. By
    \rref{I-Eq}, we already know that $[[Interp I i a0 ~ b0 : A {p | p
      =>+ refl, a0 <=> b0}]]$ and therefore it suffices to show that
    the sets $[[{p | p =>+ refl, a <=> b}]]$ and $[[{p | p =>+ refl,
      a0 <=> b0}]]$ are equal. Equivalently, it suffices to show that
    $[[a <=> b]]$ if and only if $[[a0 <=> b0]]$. By definition, from
    $[[a => a0]]$ and $[[b => b0]]$, we derive $[[a <=> a0]]$ and $[[b
    <=> b0]]$. The result then immediately follows from the fact that
    coherence is an equivalence relation
    (Lemma~\ref{lemma:coherenceequiv}).
  \item[\Rref{I-Pi}:] There exists $[[S]]$ and $[[F]]$
    such that:
    \begin{itemize}
    \item $[[Interp I i Pi A B { b | forall a, (# a in S implies b a in F
        a #) }]]$
    \item $[[Interp I i A S ]]$
    \item $[[F in S -> PowerSet STm]]$
    \item $[[forall a, (# a in S implies Interp I i B { a } F a #)]]$
    \end{itemize}
    There exists some $[[A0]]$ and $[[B0]]$ such that $[[A => A0]]$ and
    $[[B => B0]]$. Our goal is to show that $[[Interp I i Pi A0 B0 { b | forall a, (# a in S implies b a in F
      a #) }]]$. By \rref{I-Pi}, it suffices to show:
    \begin{itemize}
    \item $[[Interp I i A0 S ]]$
    \item $[[F in S -> PowerSet STm]]$
    \item $[[forall a, (# a in S implies Interp I i B0 { a } F a #)]]$
    \end{itemize}
    Since $[[A => A0]]$ and $[[B {a} => B0 {a}]]$ forall $[[a]]$, the
    latter of which follows from Lemma~\ref{lemma:parsubst}, the above
    conditions follow immediately from the induction hypothesis.
  \item[\Rref{I-Red}:] There exists $[[B0]]$ and $[[S]]$ such that $[[A => B0]]$ and
    $[[Interp I i B0 S]]$. Given an arbitrary $[[B]]$ such that $[[A
    => B]]$, our goal is to show that $[[Interp I i B S]]$. By the diamond
    property of parallel
    reduction (Lemma~\ref{lemma:pardiamond}), there exists some term
    $[[C]]$ such that $[[B0 => C]]$ and $[[B => C]]$. By the induction
    hypothesis, we derive $[[Interp I i C S]]$ from $[[Interp I i
    B0 S]]$. By \rref{I-Red} and
    $[[B => C]]$, we conclude that $[[Interp I i B S]]$.
  \end{description}
\end{proof}
From Lemma~\ref{lemma:interppreservation} and \rref{I-Red}, we can easily
derive the following corollary that two coherent types have the same
interpretation.
\begin{corollary}[Logical Relation for Coherent Types]
  \label{lemma:logrelcoherence}
  If $[[Interp I i A S]]$ and $[[A <=> B]]$, then $[[Interp I i B S]]$.
\end{corollary}
Next, we show that $[[Interp I i A S]]$ is in fact a partial function.
\begin{lemma}[Logical relation is functional]
  \label{lemma:logreldeter}
  If $[[Interp I i A S0]]$ and $[[Interp I i A S1]]$, then $[[S0 = S1]]$.
\end{lemma}
\begin{proof}
  We start by inducting over the derivation of the first premise $[[Interp I i A
  S0]]$.
  \begin{description}
  \item[\Rref{I-Void}:] We know that $[[Interp I i Void
    emptyset]]$. Given $[[Interp I i Void S1]]$, our goal is to show that
    $[[emptyset = S1]]$. This is immediate by applying the $[[Void]]$ case of
    Lemma~\ref{lemma:interpinv} to $[[Interp I i Void S1]]$.
  \item[\Rref{I-Bool, I-Eq, I-Set}:] Similar to the \rref{I-Void} case
    by applying the matching case of Lemma~\ref{lemma:interpinv}
    to $[[Interp I i A S1]]$.
  \item[\Rref{I-Pi}:] There exists $[[S]]$ and $[[F]]$
    such that:
    \begin{itemize}
    \item $[[Interp I i A S ]]$
    \item $[[F in S -> PowerSet STm]]$
    \item $[[forall a, (# a in S implies Interp I i B { a } F a #)]]$
    \end{itemize}
    Our goal is to show that given $[[Interp I i Pi A B S1]]$, we have
    $[[S1 = { b | forall a, (# a in S implies b a in F
      a #) }]]$.
    By the function case of Lemma~\ref{lemma:interpinv}, there exists
    some $[[S0]]$ and $[[F0]]$ such that:
    \begin{itemize}
    \item $[[Interp I i A S0 ]]$
    \item $[[F0 in S0 -> PowerSet STm]]$
    \item
      $[[forall a, (# a in S0 implies Interp I i B { a } F0 a #)]]$
    \item
      $[[S1 = { b | forall a, (# a in S0 implies b a in F0 a #) }]]$
    \end{itemize}
    It suffices to show that $[[S = S0]]$ and $[[F = F0]]$. The
    equality $[[S = S0]]$ immediately follows from the induction
    hypothesis since $[[Interp I i A S]]$ and $[[Interp I i A
    S0]]$. Therefore, functions $[[F]]$ and $[[F0]]$ have the same
    domain and codomain and thus it suffices to show that forall $[[a in S]]$,
    $[[F a = F0 a]]$. Suppose $[[a in S]]$, we must have $[[Interp I
    i B {a} F a]]$ and $[[Interp I i B {a} F0 a]]$ from the two
    $\forall$-quantified statements above. The equality $[[F a = F0 a]]$ then
    immediately follows from the induction hypothesis.
  \item[\Rref{I-Red}:] There exists some $[[B]]$ such that $[[A =>
    B]]$ and $[[Interp I i B S0]]$. Our goal is to show that given
    $[[Interp I i A S1]]$, we have $[[S0 = S1]]$. By
    Lemma~\ref{lemma:interppreservation}, from $[[Interp I i A S1]]$
    and $[[A => B]]$, we have $[[Interp I i B S1]]$. From the
    induction hypothesis, we can conclude that $[[S0 = S1]]$ since
    $[[Interp I i B S0]]$ and $[[Interp I i B S1]]$.
  \end{description}
\end{proof}

Lemma~\ref{lemma:logreldeter} enables us to derive the following
alternative introduction and inversion principles for \rref{I-Pi}.
\begin{lemma}[Pi Intro Alt]
  \label{lemma:piintroalt}
  Suppose the following two statements hold:
  \begin{itemize}
  \item $[[Interp I i A S]]$
  \item $[[forall a, a in S implies (# exists S0 , Interp I i B {a} S0 #)]]$
  \end{itemize}
  Then we have $[[Interp I i Pi A B { b | forall a, (# a in S , forall
    S0, (# Interp I i B {a} S0,  b a in F a #) #) }]]$
\end{lemma}
\begin{proof}
  Let $[[F]]$ be the relation defined as follows:
  \[ (a,S) \in [[F]] \iff [[Interp I i B {a} S]] \]
  By the second bullet from the premise and
  Lemma~\ref{lemma:logreldeter}, $[[F]]$ is a function that is total
  on the set $[[S]]$. The conclusion then trivially follows from
  \rref{I-Pi}.
\end{proof}

\begin{lemma}[Pi Inv Alt]
  \label{lemma:piinvalt}
  Suppose $[[Interp I i Pi A B S]]$, then there exists some $[[S0]]$
  such that the following constraints hold:
  \begin{itemize}
  \item $[[Interp I i A S0]]$
  \item $[[forall a, (# a in S0 implies (# exists S1 , Interp I i B {a}
    S1 #) #)]]$
  \item $[[S = { b | forall a, (# a in S0 , forall
    S1, (# Interp I i B {a} S1,  b a in F a #) #) }]]$
  \end{itemize}
\end{lemma}
\begin{proof}
  Immedaite from Lemmas~\ref{lemma:interpinv} and \ref{lemma:logreldeter}.
\end{proof}

% The combination of Lemmas~\ref{lemma:piintroalt} and
% \ref{lemma:piinvalt} reveals what we truly want to capture with
% \rref{I-Pi}. A function type is semantically well-defined if its input
% type is well-defined, and its output type is defined for each valid
% inahbitant of its input type.

The next lemma shows that our logical relation satisfies
cumulativity. That is, if a type has an interpretation at a lower
universe level, then we can obtain the same interpretation at a higher
universe level.
\begin{lemma}[Logical relation cumulativity]
  \label{lemma:logrelcumulativity}
  If $[[Interp I i0 A S]]$ and $[[i0 < i1]]$, then $[[Interp I i1 A S]]$.
\end{lemma}
\begin{proof}
  Trivial by structural induction over the derivation of $[[Interp I
  i0 A S]]$.
\end{proof}
Note that in the statement of Lemma~\ref{lemma:logrelcumulativity}, we
implicitly assume that $[[I]]$ is defined on the set of natural
numbers less than $[[i1]]$.

\begin{corollary}[Logical relation is functional with different levels]
  \label{lemma:logreldeterhet}
  If $[[Interp I i0 A S0]]$ and $[[Interp I i1 A S1]]$, then $[[S0 = S1]]$.
\end{corollary}
\begin{proof}
  Immediate from Lemma~\ref{lemma:logreldeter} and
  \ref{lemma:logrelcumulativity}.
\end{proof}

We say that a set of terms $[[S]]$ is closed under expansion if given
$[[a in S]]$, then $[[b in S]]$ for all $[[b => a]]$.
The final property we want to show is that the output set $[[S]]$ from
the logical relation is closed under expansion. Unlike the previous
lemmas, we need to constrain the function $[[I]]$ so its outputs are
all closed under expansion.
\begin{lemma}[Logical Relation Elements back preservation]
  \label{lemma:logrelbackclos}
  If $[[Interp I i A S]]$ and $[[I]]$ satisfies the property that
  for all $[[i]]$, $[[I i]]$ is closed under expansion, then the set
  $[[S]]$ is closed under expansion.
\end{lemma}
\begin{proof}
  Trivial by structural induction over the derivation of $[[Interp I i
  A S]]$. The function case requires the following simple fact about
  parallel reduction:
  If $[[b0 => b1]]$ then $[[b0 a => b1 a]]$ for all $[[a]]$. This fact
  is not immediate from the definition of parallel reduction but
  follows from Lemma~\ref{lemma:parrefl} and \rref{P-App}.
\end{proof}

\begin{corollary}
  \label{lemma:logrelNbackclos}
  If $[[InterpR i A S]]$, then $[[S]]$ is closed under expansion.
\end{corollary}
\begin{proof}
  Immediate from Lemma~\ref{lemma:logrelbackclos}, the definition of
  $[[InterpR i A S]]$, and \rref{I-Red}.
\end{proof}

\section{Semantic Typing and Consistency}
\label{sec:logrelproof}
\begin{figure}[h]
  \begin{equation*}
    \begin{split}
      [[rho |= G]] &:= \forall i\ j\ S, \text{ if }[[i < |G|]]\text{ and
                     } [[InterpR j (up S i G i) { rho } S ]] \text{, then } [[rho i in S]] \\
      [[G |= a : A]] &:= \forall [[rho]], \text{ if }[[rho |=
                       G]]\text{ then there exists some } [[j]] \text{
                       and } [[S]] \text{ such that } [[InterpR j A
                       {rho} S]] \text{ and } [[a {rho} in S]] \\
      [[|= G]] &:= \forall [[i < |G|]], \exists [[j]], [[drop S i G |= G i : Set j]]
    \end{split}
  \end{equation*}
  \caption{Semantic Typing for \lang}
  \label{fig:semtyping}
\end{figure}


The logical relation we define in Figure~\ref{fig:logrel} does not
include cases for variables. Likewise, for the base types such as
boolean and equality, the output set $[[S]]$ contains only terms that
evaluate to closed terms. To generalize our logical relation to open
terms, we define the semantic typing judgment by closing the open
terms with a substitution whose codomain consists of terms that
respect the interpretation of the types from the context. The full
definitions of well-formed substitution ($[[rho |= G]]$), semantic
typing ($[[ G |= a : A]]$), and semantic context well-formedness
($[[|= G]]$) are presented in Figure~\ref{fig:semtyping}.

Next, we show that semantic typing is implied by syntactic typing
case-by-case through a series of lemmas.

\begin{lemma}[Set Inv]
  \label{lemma:setinv}
  The following two statements are equivalent:
  \begin{itemize}
  \item $[[G |= A : Set i]]$
  \item For all $[[rho]]$, if $[[rho |= G]]$, then there exists
    $[[S]]$ such that $[[InterpR i (A {rho}) S]]$
  \end{itemize}
\end{lemma}
\begin{proof}
  The forward direction is immediate by
  Lemma~\ref{lemma:interpinv}. We now consider the backward direction
  and show that $[[G |= A : Set i]]$ given the second bullet.

  Suppose $[[rho |= G]]$, then we know that there exists some $[[S]]$
  such that $[[InterpR i (A {rho}) S]]$. By the definition of semantic
  typing, it suffices to show that there exists some $[[j]]$ and
  $[[S0]]$ such that  $[[InterpR j Set i S0]]$ and $[[A {rho} in
  S0]]$.
  Pick $[[S i]]$ for $[[j]]$ and $[[ { A | exists S , InterpR i A S }
  ]]$ for $[[S0]]$ and it's trivial to verify the conditions hold.
\end{proof}

The semantic context well-formedness judgment ($[[|= G]]$), unlike its syntactic
counterpart $[[|- G]]$, is defined through a for all quantified statement rather
than inductively over the context. It is easy to recover the same
structural rules:
\begin{lemma}[TODO]

\end{lemma}

Likewise, the semantic well-formendness judgment for substitutions
satisfies similar structural rules.
\begin{lemma}[Well-formed $[[rho]]$ cons]
  If $[[InterpR i A S]]$, $[[a in S]]$, and $[[rho |= G]]$, then
  $[[rho .: a |= G ++ A]]$.
\end{lemma}



\begin{lemma}[ST-Var]
  If $[[|= G]]$ and $[[i < |G|]]$, then $[[G |= i : up S i G i]]$.
\end{lemma}

\begin{lemma}[ST-Set]
  If $[[i < j]]$, then $[[G |= Set i : Set j]]$.
\end{lemma}
\begin{proof}
  Immedaite by Lemma~\ref{lemma:setinv} and \rref{I-Set}.
\end{proof}

\begin{lemma}[ST-Pi]
  If $[[G |= A : Set i]]$ and $[[G ++ A |= B : Set i]]$, then $[[G |= Pi
  A B : Set i]]$.
\end{lemma}
\begin{proof}
  Applying Lemma~\ref{lemma:setinv} to the
  conclusion, it now suffices to show that given $[[rho |= G]]$, there
  exists some $[[S]]$ such that $[[InterpR i Pi A B S]]$.
  From Lemma~\ref{lemma:setinv} and $[[G |= A : Set i]]$, we know that
  there exists some set $[[S0]]$ such that $[[InterpR i A S0]]$.
From $[[G ++ A |= B : Set i]]$, we know that there must
exists $[[S]]$ such that $[[InterpR i B {rho .: a} S]]$ for every $[[a
in S0]]$. The conclusion immediately follows from Lemma~\ref{lemma:piintroalt}.
\end{proof}

\section{Mechanization}
\label{sec:logrelmech}

\section{Related Work}
\label{sec:relatedwork}

% Type soundness can be proven through a syntactic
% approach~\citep{syntacticsoundness} as a corollary of two properties:
% progress and preservation. % The syntactic type soundness proof
% % varies in complexity depending on the underlying type
% % system. For example, a type system that tracks information flow would
% % require additional structural rules related to security levels. In
% % this paper, we focus on one specific type of complexity: the
% In Figure~\ref{fig:stlcsoundness}, we summarize the structure of the
% syntactic type soundness proof for the simply typed lambda
% calculus. Each lemma can be proven by structural induction over the
% typing derivation, while using the previous established results as
% lemmas for specific cases that do not immediately follow from the
% induction hypothesis. If we make our language more complex by adding
% full dependent type support, the overall structure remains almost
% identical.


% NbE in Coq

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{refs}


%%
%% If your work has an appendix, this is the place to put it.

\end{document}
\endinput
%%
%% End of file `sample-acmsmall.tex'.
